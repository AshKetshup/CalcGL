\chapter{Estado da Arte}
\label{ch::arte}

\section{Introdução}
\label{sec::arte:intro}

A visualização computacional de funções é a base de muitas aplicações práticas em computação gráfica, tais como em videojogos e visualização molecular. O estudo destas funções permite igualmente outro tipo de cálculos, tais como colisões.

Para alcançar os objetivos propostos no presente projeto, é imperativo estudar os seguintes tópicos:

\begin{itemize}
	\item Funções implícitas;
	\item Técnicas de renderização em geral e algoritmos volumétricos em particular;
	\item Uso da \ac{API} \opengl e programação em \ac{GLSL}.
\end{itemize}


\section{Funções Implícitas}
\label{sec::arte:implicitas}

%\subsection{Definição e Aplicações}
%\label{ssec::arte:implicitas:def}

% O que é? Exemplo(s). Que aplicações têm?

Às funções definidas em função de uma variável dá-se o nome de \textbf{funções explícitas}. Exemplos clássicos em $\mathbb{R}^2$ incluem equações de retas ($y = mx + b$) e parábolas ($y = ax^2 + bx + c$). Ora, nem todos os subconjuntos de pontos no espaço cartesiano podem ser definidos por funções explícitas. Um exemplo comum em $\mathbb{R}^2$ é a circunferência:

\begin{equation}
	(x - x_0)^2 + (y - y_0)^2 = r^2
	\label{eq::circ_implicita}
\end{equation}

onde $(x_0, y_0)$ é o centro e $r$ o raio. Exemplifica-se na Figura \ref{fig::circumference} a circunferência definida por $(x - 1)^2 + (y - 2)^2 = 4$.

\begin{figure}[!btp]
	\centering
	\includegraphics[scale=1.0]{circumference}
	\caption[Exemplo de uma circunferência]{Exemplo de uma circunferência de centro $(1, 2)$ e raio $2$.}
	\label{fig::circumference}
\end{figure}

Sendo uma equação de segundo grau, é possível representá-la através de duas funções explícitas:

\begin{eqnarray}
		y = y_0 + \sqrt{r^2 - (x - x_0)^2} \\
		y = y_0 - \sqrt{r^2 - (x - x_0)^2}
\end{eqnarray}

Esta transformação não é possível para todos os polinómios, em particular para graus superiores a $4$. Contudo, estas expressões polinomiais continuam a ser subconjuntos válidos de $\mathbb{R}^n$, necessitando então de formas alternativas de representação. Dois métodos e respetivas representações da circunferência são:

\begin{enumerate}
	\item \textbf{Funções paramétricas}: cada eixo é definido em ordem a uma variável adicional $t$:
	\begin{equation}
		\left\{\begin{array}{l}
			x = r\cos(t) \\
			y = r\sin(t)
		\end{array}\right.
	\label{eq::circ_parametrica}
	\end{equation}
	
	\item \textbf{Funções implícitas}: a equação não é definida a ordem a uma variável em particular (equação (\ref{eq::circ_implicita})).
\end{enumerate}

Uma \textbf{função implícita} é então definida por $f~:~\mathbb{R}^n \longrightarrow \mathbb{R}$, ou seja, para qualquer ponto em $\mathbb{R}^n$ é determinado um resultado em $\mathbb{R}$. Dependendo da função, o valor obtido pode ter significado, tal como uma grandeza física (\textit{e.g.} densidade de um líquido ou sua temperatura a cada ponto do espaço). Esta função diz-se \textbf{algébrica} caso seja polinomial em cada variável.

Por seu turno, em $\mathbb{R}^3$, a \textbf{iso-superfície} de uma função implícita é a superfície que satisfaz a condição $f(\mathbf{x}) = 0$ (onde, doravante, $\mathbf{x} \equiv (x,y,z)$). Esta pode ser suavizada através de um parâmetro $s \in \mathbb{R}$ tal que $f(\mathbf{x}) - s = 0$. Este efeito é utilizado diretamente e com sucesso nas Superfícies $\Pi$ \cite{Raposo2019}.

\todo{Mais aplicações.}


\section{Renderização de Superfícies Implícitas}
\label{sec::arte:render}

Muitos algoritmos de renderização têm vindo a ser investigados e usados em \textit{software} que implemente diversas técnicas para obter uma imagem final.

A nossa visão capta a luz refletida por objetos num determinado cenário. Durante o processo, uma parte dos comprimentos de onda das fontes de luz são absorvidos pelos objetos, sendo a restante refletida. Como resultado final, os comprimentos de onda refletidos e captados pelos olhos constituem o que é interpretado pelo cérebro como \textbf{cor}.

No entanto, a determinação do percurso de cada partícula de luz (ou fotão) num dado cenário é na grande maioria dos casos algo impraticável devido ao volume de cálculos envolvidos, com a consequente demora na obtenção dos resultados.

Neste sentido, foram desenvolvidos métodos mais eficientes de cálculo, tais como:

\begin{itemize}
    \item \textbf{Rasterização}: técnica ainda usada na \textit{pipeline} do \opengl, consiste na conversão de uma imagem descrita geometricamente em 3D numa série de pixeis que, no seu todo, criam a sua imagem representativa em 2D;
    
    \item \textbf{\itshape Ray Casting}: considerando um cenário a ser observado a partir de um determinado ponto de vista, este algoritmo calcula a imagem observada com base na geometria e em leis óticas fundamentais;
    
    \item \textbf{\itshape Ray Tracing}: funcionalmente semelhante ao \textit{Ray Casting}, recorre a simulações óticas mais avançadas para a criação de cenários mais realistas.
\end{itemize}

\todo{Imagens de exemplo de cada técnica.}

Neste âmbito, as funções implícitas representam simultaneamente uma grande oportunidade e um enorme desafio na área da computação gráfica. Se por um lado é possível obter a visualização de formas geométricas complexas com recurso a funções implícitas, por outro não há um método direto de determinar os pontos da iso-superfície. Vários algoritmos para este fim têm sido propostos ao longo das últimas décadas. Para fins do presente Estado da Arte, estes podem ser categorizados em dois grandes grupos:

\begin{enumerate}
	\item \textbf{Triangulação}: A iso-superfície é dividida em triângulos, os quais formam a \textit{mesh} a ser renderizada pela \ac{GPU}. Exemplos incluem:
	\begin{itemize}[nosep]
		\item \textit{Marching cubes}\cite{Lorensen1987}: O espaço é dividido em cubos onde o valor da função implícita é calculado para cada vértice. A análise dos sinais permite determinar quais arestas do cubo a superfície interseta, num total de 256 possíveis combinações de triângulos.
	\end{itemize}
	
	\item \textbf{Algoritmos volumétricos}: \todo{Breve descrição}. Exemplos incluem:
	\begin{itemize}
		\item \textit{Ray marching}: \todo{Breve descrição}.
		\item \textit{Sphere tracing}\cite{Hart1996}: Um caso particular de \textit{ray marching} onde esferas são usadas para determinar a distância mínima aos objetos do cenário.
		\item \textit{Ray tracing} (previamente descrito).
	\end{itemize}
\end{enumerate}
%	\item \textbf{\textit{Ray Tracing}}:\\
%    \revision{} \todo{Citar um artigo de Ray Tracing}\\
%     Um \textit{viewport} é definido a uma distância da câmara. É a partir da mesma que são enviados raios na direção de cada pixel. É calculado o ponto de interseção com a superfície em cena e o mesmo é refletido. Este processo é repetido uma quantia pre-definida até por fim obter a cor a usar.


\section{\emph{Ray Marching}}
\label{sec::arte:raymarch}

\hint{Como funciona o algoritmo? É paralelizável? Se sim, como e porquê?}

\revision{\textit{Ray marching} é uma técnica de renderização que tal como no tradicional \textit{ray tracing}, não é tão simples de resolver uma superfície (ou até impossível caso sem o uso de métodos numéricos interativos). Em \textit{ray tracing} apenas nos focamos na interseção do raio emitido com a superfície, enquanto no algoritmo de \textit{ray marching} marchamos na direção tomada até encontrarmos uma interseção (isto se a mesma existir).}

\subsection{Ray Casting}
Como em qualquer algoritmo da família \textit{ray casting}, \textit{ray marching} começa com um viewport definido por um plano a uma determinada distância (representando o \ac{FOV}) da câmara em que para cada pixel do dado \textit{viewport} é enviado um raio na dada direção.

\begin{equation}
    (x, y, z) = P + s \times \overrightarrow{v}
\end{equation}

\begin{equation}
    (x, y, z) = P + s \times \overrightarrow{v} + t \times \overrightarrow{u}
\end{equation}

\begin{equation}
    \overrightarrow{d} = P - C
\end{equation}




\subsection{Algoritmo naïve}
Em \textit{ray tracing} apenas nos focamos na interseção do raio emitido com a superfície, enquanto no algoritmo de \textit{ray marching} marchamos na direção tomada até encontrarmos uma interseção (isto se a mesma existir).\\

Esta técnica é de particular interesse nos seguintes casos:
\begin{itemize}
    \item Necessidade de renderizar volumes que não são uniformes;
    \item Renderização de funções implícitas ou fractais;
    \item Renderização de outros tipos de funções paramétricas onde a interseção não é conhecida antecipadamente, como \textit{parallel mapping}.
\end{itemize}

% \subsection{Algoritmo naïve}
% \label{ssec::arte:raymarch:naive}
% 
% O algoritmo geral de \textit{ray marching} contempla os seguintes quatro passos:
% 
% \begin{enumerate}
% 	\item \textbf{\textit{Ray casting}}:
% 	
% 	\item \textbf{\textit{Sampling}}:
% 	
% 	\item \textbf{\textit{Shading}}:
% 	
% 	\item \textbf{\textit{Compositing}}:
% \end{enumerate}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=.8\textwidth]{raymarch2D}
    \caption[Demonstração do algoritmo Ray Marching em 2D]{Demonstração do algoritmo Ray Marching em 2D.}
    \label{fig::rmarching2D}
\end{figure}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=.8\textwidth]{bisection}
    \caption[Processo de \textit{bisection} usado no algoritmo naïve]{Processo de \textit{bisection} usado no algoritmo naïve.}
    \label{fig::rmarching2DBisection}
\end{figure}

\todo{Algoritmo naïve}
\begin{algorithm}[!htbp]
	\caption{Algoritmo naïve de \textit{ray marching}.}
	\label{alg::raymarch_naive}
	\begin{algorithmic}
\Require função $f$      \Comment{Função implícita}
	\end{algorithmic}
\end{algorithm}


\subsection{Sphere Tracing}
\label{ssec::arte:raymarch:spheretracing}

\revision{Reformular o português. A ideia está cá, mas para quem não está dentro do projeto pode sentir-se um pouco perdido. Nada de grave, don't worry :)}

\textit{Sphere tracing} é um possível algoritmo de \textit{ray marching}. No entanto, nem todos os usos de \textit{ray marching} beneficiam deste método, porque estes não conseguem ser convertidos para este esquema.

\textit{Sphere tracing} é usado para renderizar \textbf{superfícies implícitas}. Visto que esta função pode ser resolvida para cada ponto, podemos ir em frente e estimar a maior esfera possível que possa caber no atual passo de marcha. Então sabemos que a próxima distância a marchar é pelo menos tão grande quanto o raio da dita esfera. Desta forma adaptamos então o número de passos a marchar e tornamos com o processo muito mais rápido.

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=.8\textwidth]{stracing2D}
    \caption[Demonstração do algoritmo Sphere Tracing em 2D]{Demonstração do algoritmo Sphere Tracing em 2D.}
    \label{fig::stracing2D}
\end{figure}


No entanto em \textit{sphere tracing} é um requisito saber calcular com antecipação a distância minima entre um dado ponto e a superfície em questão. Dão-se a estas funções o nome de \textbf{\ac{SDF}}. O uso das mesmas torna impraticável a aplicação de \textit{sphere tracing} para funções implícitas de geometria desconhecida.

\todo{Imagem de exemplo de uma SDF}

\begin{algorithm}[!htbp]
	\caption{Algoritmo de \textit{sphere tracing}.}
	\label{alg::raymarch_spheretrace}
	\begin{algorithmic}
\Require função $f$      \Comment{Função implícita}
	\end{algorithmic}
\end{algorithm}


\section{\opengl}
\label{sec::arte:opengl}

\hint{Não recomendo um rip-off do meu relatório, mas ele pode servir de base para esta secção, tentando melhorá-lo e corrigir possíveis gafes.}


\subsection{Pipeline}
A renderização de um dado objeto atravessa diversas fases, ao conjunto das mesmas é dado o nome de \textbf{\textit{pipeline} de renderização}. A partir da versão 3.3, intitulado de "\opengl moderno", a \textit{pipeline} possui determinados pontos onde o programador tem a capacidade de implementar como a \ac{GPU} se deverá comportar, através de do que chamamos de \textit{shaders}.

A \textit{pipeline} é inicializada sempre que uma operação de renderização for feita. Estas operações requerem o uso obrigatório de um \ac{VAO} propriamente definido e em conjunto associado a um \textit{Program Object} ou um \textit{Program Pipeline Object} que fornece os \textit{shaders} para as fases da \textit{pipeline}. 
A ordem e as mencionadas fases são:
\begin{enumerate}
    \item \textbf{Processamento de vértices} (\textit{vertex processing}): 
    A maioria das fases durante o processamento de vértices são programáveis, o que permite o código do utilizador customizar como os vértices são processados.
    Cada vértice recebido pelo \ac{VAO} é usado por um \textit{vertex shader} tornando-o num vértice de saída. Opcionalmente é nos disponibilizado uma fase de tesselação (\textit{tessellation stage}) assim como um também opcional processamento de primitivas com o uso de um \textit{geometry shader}, este devolve uma sequência de primitivas.
    
    \item \textbf{Pós-processamento de vértices} (\textit{vertex post-processing}):
    Durante este processo os vértices disponíveis são filtrados pela condição de serem compreendidos no \textit{viewport} atual. Os mesmos também poderão ser transportados para diferentes localizações no espaço.
    
    \item \textbf{Rasterização} (\textit{rasterization}): É neste processo que as primitivas são divididas em elementos independentes designados de \textbf{fragmentos}. Por norma, cada pixel é associado a pelo um fragmento.
    
    \item \textbf{Processamento de Fragmentos} através de \textit{fragment shader}: Para cada fragmento é gerado uma quantia de \textit{outputs} (por exemplo a cor), através do processamento de um \textit{fragment shader}.
    
    \item \textbf{Processamento por Amostra} (\textit{per-sample processing}): Com os resultados devolvidos pelo \textit{fragment shader}, os mesmos passam por diversos testes em que ao passar a todos resulta então em um pixel final.
\end{enumerate}

\subsection{Shaders}
Aos programas executados pela \ac{GPU} num determinado ponto da pipeline de renderização chamamos de \textit{shaders}. Por entre os diversos \textit{shaders} disponíveis para implementação, são destacados dois de interesse a este projeto:

\begin{enumerate}
    \item \textbf{Vertex Shader}\\
    Obtendo um vértice no espaço a partir do \ac{VAO}, este \textit{shader} é usado no processamento de vértices. Tradicionalmente realiza operações matriciais \ac{MVP}.
    
    \item \textbf{Fragment Shader}\\
    Obtendo um fragmento após o processo de rasterização, o \textit{fragment shader} é capaz de o processar individualmente resultando numa determinada cor em conjunto de uma profundidade. Regularmente, é durante o mesmo que são aplicadas operações de iluminação e coloração.
\end{enumerate}

Os \textit{shaders} são compilados em \textit{runtime} pelo \opengl, neles usam uma linguagem própria, com sintaxe bastante próxima ao \verb*|C|, nomeada de \ac{GLSL}.
É possível enviar uma cópia de dados da \ac{CPU} para a \ac{GPU} (da memória \ac{RAM} para a \ac{VRAM}) dando uso a \textbf{variáveis uniformes} (\textit{uniforms}), estas funcionam como variáveis globais em qualquer shaders disponíveis para implementação.

No entanto, dados relativos a vértices, normais e cores são passados por \textit{buffers}.

\subsection{\emph{Buffers} e Atributos}
\todo{mencionar vao}


\subsection{Texturas}
\todo{mencionar textures}


\section{Conclusões}
\label{sec::arte:conc}

\ldots Whiskas Saquetas.
