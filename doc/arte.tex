\chapter{Estado da Arte}
\label{ch::arte}

\section{Introdução}
\label{sec::arte:intro}

A visualização computacional de funções é a base de muitas aplicações práticas em computação gráfica, tais como em videojogos e visualização molecular. O estudo destas funções permite igualmente outro tipo de cálculos, tais como colisões.

Para alcançar os objetivos propostos no presente projeto, é imperativo estudar os seguintes tópicos:

\begin{itemize}
	\item Funções implícitas;
	\item Técnicas de renderização em geral e algoritmos volumétricos em particular;
	\item Uso da \ac{API} \opengl e programação em \ac{GLSL}.
\end{itemize}


\section{Funções Implícitas}
\label{sec::arte:implicitas}

%\subsection{Definição e Aplicações}
%\label{ssec::arte:implicitas:def}

% O que é? Exemplo(s). Que aplicações têm?

Às funções definidas em função de uma variável dá-se o nome de \textbf{funções explícitas}. Exemplos clássicos em $\mathbb{R}^2$ incluem equações de retas ($y = mx + b$) e parábolas ($y = ax^2 + bx + c$). Ora, nem todos os subconjuntos de pontos no espaço cartesiano podem ser definidos por funções explícitas. Um exemplo comum em $\mathbb{R}^2$ é a circunferência:

\begin{equation}
	(x - x_0)^2 + (y - y_0)^2 = r^2
	\label{eq::circ_implicita}
\end{equation}

onde $(x_0, y_0)$ é o centro e $r$ o raio. Exemplifica-se na Figura \ref{fig::circumference} a circunferência definida por $(x - 1)^2 + (y - 2)^2 = 4$.

\begin{figure}[!btp]
	\centering
	\includegraphics[scale=1.0]{circumference}
	\caption[Exemplo de uma circunferência]{Exemplo de uma circunferência de centro $(1, 2)$ e raio $2$.}
	\label{fig::circumference}
\end{figure}

Sendo uma equação de segundo grau, é possível representá-la através de duas funções explícitas:

\begin{eqnarray}
		y = y_0 + \sqrt{r^2 - (x - x_0)^2} \\
		y = y_0 - \sqrt{r^2 - (x - x_0)^2}
\end{eqnarray}

Esta transformação não é possível para todos os polinómios, em particular para graus superiores a $4$. Contudo, estas expressões polinomiais continuam a ser subconjuntos válidos de $\mathbb{R}^n$, necessitando então de formas alternativas de representação. Dois métodos e respetivas representações da circunferência são:

\begin{enumerate}
	\item \textbf{Funções paramétricas}: cada eixo é definido em ordem a uma variável adicional $t$:
	\begin{equation}
		\left\{\begin{array}{l}
			x = r\cos(t) \\
			y = r\sin(t)
		\end{array}\right.
	\label{eq::circ_parametrica}
	\end{equation}
	
	\item \textbf{Funções implícitas}: a equação não é definida a ordem a uma variável em particular (equação (\ref{eq::circ_implicita})).
\end{enumerate}

Uma \textbf{função implícita} é então definida por $f~:~\mathbb{R}^n \longrightarrow \mathbb{R}$, ou seja, para qualquer ponto em $\mathbb{R}^n$ é determinado um resultado em $\mathbb{R}$. Dependendo da função, o valor obtido pode ter significado, tal como uma grandeza física (\textit{e.g.} densidade de um líquido ou sua temperatura a cada ponto do espaço). Esta função diz-se \textbf{algébrica} caso seja polinomial em cada variável.

Por seu turno, em $\mathbb{R}^3$, a \textbf{iso-superfície} de uma função implícita é a superfície que satisfaz a condição $f(\mathbf{x}) = 0$ (onde, doravante, $\mathbf{x} \equiv (x,y,z)$). Esta pode ser suavizada através de um parâmetro $s \in \mathbb{R}$ tal que $f(\mathbf{x}) - s = 0$. Este efeito é utilizado diretamente e com sucesso nas Superfícies $\Pi$ \cite{Raposo2019}.

\todo{Mais aplicações.}


\section{Renderização de Superfícies Implícitas}
\label{sec::arte:render}

Muitos algoritmos de renderização têm vindo a ser investigados e usados em \textit{software} que implemente diversas técnicas para obter uma imagem final.

A nossa visão capta a luz refletida por objetos num determinado cenário. Durante o processo, uma parte dos comprimentos de onda das fontes de luz são absorvidos pelos objetos, sendo a restante refletida. Como resultado final, os comprimentos de onda refletidos e captados pelos olhos constituem o que é interpretado pelo cérebro como \textbf{cor}.

No entanto, a determinação do percurso de cada partícula de luz (ou fotão) num dado cenário é na grande maioria dos casos algo impraticável devido ao volume de cálculos envolvidos, com a consequente demora na obtenção dos resultados.

Neste sentido, foram desenvolvidos métodos mais eficientes de cálculo, tais como:

\begin{itemize}
    \item \textbf{Rasterização}: técnica ainda usada na \textit{pipeline} do \opengl, consiste na conversão de uma imagem descrita geometricamente em 3D numa série de pixeis que, no seu todo, criam a sua imagem representativa em 2D;
    
    \item \textbf{\itshape Ray Casting}: considerando um cenário a ser observado a partir de um determinado ponto de vista, este algoritmo calcula a imagem observada com base na geometria e em leis óticas fundamentais;
    
    \item \textbf{\itshape Ray Tracing}: funcionalmente semelhante ao \textit{Ray Casting}, recorre a simulações óticas mais avançadas para a criação de cenários mais realistas.
\end{itemize}

\todo{Imagens de exemplo de cada técnica.}

Neste âmbito, as funções implícitas representam simultaneamente uma grande oportunidade e um enorme desafio na área da computação gráfica. Se por um lado é possível obter a visualização de formas geométricas complexas com recurso a funções implícitas, por outro não há um método direto de determinar os pontos da iso-superfície. Vários algoritmos para este fim têm sido propostos ao longo das últimas décadas. Para fins do presente Estado da Arte, estes podem ser categorizados em dois grandes grupos:

\begin{enumerate}
	\item \textbf{Triangulação}: A iso-superfície é dividida em triângulos, os quais formam a \textit{mesh} a ser renderizada pela \ac{GPU}. Exemplos incluem:
	\begin{itemize}[nosep]
		\item \textit{Marching cubes}\cite{Lorensen1987}: O espaço é dividido em cubos onde o valor da função implícita é calculado para cada vértice. A análise dos sinais permite determinar quais arestas do cubo a superfície interseta, num total de 256 possíveis combinações de triângulos.
	\end{itemize}
	
	\item \textbf{Algoritmos volumétricos}: \todo{Breve descrição}. Exemplos incluem:
	\begin{itemize}
		\item \textit{Ray marching}: \todo{Breve descrição}.
		\item \textit{Sphere tracing}\cite{Hart1996}: Um caso particular de \textit{ray marching} onde esferas são usadas para determinar a distância mínima aos objetos do cenário.
		\item \textit{Ray tracing} (previamente descrito).
	\end{itemize}
\end{enumerate}


\section{\emph{Ray Marching}}
\label{sec::arte:raymarch}

\hint{Como funciona o algoritmo? É paralelizável? Se sim, como e porquê?}

\revision{\textit{Ray marching} é uma técnica de renderização que tal como no tradicional \textit{ray tracing}, não é tão simples de resolver uma superfície (ou até impossível caso sem o uso de métodos numéricos interativos). Em \textit{ray tracing} apenas nos focamos na interseção do raio emitido com a superfície, enquanto no algoritmo de \textit{ray marching} marchamos na direção tomada até encontrarmos uma interseção (isto se a mesma existir).}

Esta técnica é de particular interesse nos seguintes casos:
\begin{itemize}
    \item Necessidade de renderizar volumes que não são uniformes;
    \item Renderização de funções implícitas ou fractais;
    \item Renderização de outros tipos de funções paramétricas onde a interseção não é conhecida antecipadamente, como \textit{parallel mapping}.
\end{itemize}

\subsection{Algoritmo naïve}
\label{ssec::arte:raymarch:naive}

O algoritmo geral de \textit{ray marching} contempla os seguintes quatro passos:

\begin{enumerate}
	\item \textbf{\textit{Ray casting}}:
	
	\item \textbf{\textit{Sampling}}:
	
	\item \textbf{\textit{Shading}}:
	
	\item \textbf{\textit{Compositing}}:
\end{enumerate}

\todo{Imagem de exemplo algoritmo naïve em 2D}\\
\todo{Algoritmo naïve}

\begin{algorithm}[!htbp]
	\caption{Algoritmo naïve de \textit{ray marching}.}
	\label{alg::raymarch_naive}
	\begin{algorithmic}
\Require função $f$      \Comment{Função implícita}
	\end{algorithmic}
\end{algorithm}


\subsection{Sphere Tracing}
\label{ssec::arte:raymarch:spheretracing}

\revision{Reformular o português. A ideia está cá, mas para quem não está dentro do projeto pode sentir-se um pouco perdido. Nada de grave, don't worry :)}

\textit{Sphere tracing} é um possível algoritmo de \textit{ray marching}. No entanto, nem todos os usos de \textit{ray marching} beneficiam deste método, porque estes não conseguem ser convertidos para este esquema.

\textit{Sphere tracing} é usado para renderizar \textbf{superfícies implícitas}. Visto que esta função pode ser resolvida para cada ponto, podemos ir em frente e estimar a maior esfera possível que possa caber no atual passo de marcha. Então sabemos que a próxima distância a marchar é pelo menos tão grande quanto o raio da dita esfera. Desta forma adaptamos então o número de passos a marchar e tornamos com o processo muito mais rápido.

\todo{Imagem de exemplo algoritmo spheretracing em 2D}

No entanto em \textit{sphere tracing} é um requisito saber calcular com antecipação a distância minima entre um dado ponto e a superfície em questão. Dão-se a estas funções o nome de \textbf{\ac{SDF}}. O uso das mesmas torna impraticável a aplicação de \textit{sphere tracing} para funções implícitas de geometria desconhecida.

\todo{Imagem de exemplo de uma SDF}

\begin{algorithm}[!htbp]
	\caption{Algoritmo de \textit{sphere tracing}.}
	\label{alg::raymarch_spheretrace}
	\begin{algorithmic}
\Require função $f$      \Comment{Função implícita}
	\end{algorithmic}
\end{algorithm}


\section{\opengl}
\label{sec::arte:opengl}

\hint{Não recomendo um rip-off do meu relatório, mas ele pode servir de base para esta secção, tentando melhorá-lo e corrigir possíveis gafes.}


\section{Conclusões}
\label{sec::arte:conc}

\ldots Whiskas Saquetas.
